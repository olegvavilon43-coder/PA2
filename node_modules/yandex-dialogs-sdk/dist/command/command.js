"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const textRelevance_1 = require("../utils/textRelevance");
class Command {
    constructor(matcher, callback) {
        this._matcher = matcher;
        this._callback = callback;
    }
    async getRelevance(context) {
        return this._matcher.call(null, context);
    }
    async run(context) {
        return this._callback.call(null, context);
    }
    static createCommand(declaration, callback) {
        if (typeof declaration === 'function') {
            return new Command(declaration, callback);
        }
        if (typeof declaration === 'string') {
            return new Command(this.createMatcherFromString(declaration), callback);
        }
        if (Array.isArray(declaration)) {
            return new Command(this.createMatcherFromStrings(declaration), callback);
        }
        if (declaration instanceof RegExp) {
            return new Command(this.createMatcherFromRegExp(declaration), callback);
        }
        throw new Error('Command declaration is not of proper type. ' +
            'Could be only string, array of strings, RegExp or function.');
    }
    static createMatcherFromString(pattern, params = {}) {
        if (typeof pattern === undefined) {
            return () => 0;
        }
        pattern = pattern ? pattern.toLowerCase() : '';
        const { relevanceProvider = textRelevance_1.getLevenshteinRelevance, } = params;
        return (context) => {
            const commandLower = context.data.request.command ?
                context.data.request.command.toLowerCase() : '';
            if (commandLower === pattern) {
                return 1;
            }
            return relevanceProvider(pattern, commandLower);
        };
    }
    static createMatcherFromStrings(patterns, params = {}) {
        if (!patterns || !patterns.length) {
            return () => 0;
        }
        patterns = patterns.map(s => s.toLowerCase());
        const { relevanceProvider = textRelevance_1.getLevenshteinRelevance, } = params;
        return (context) => {
            const commandLower = context.data.request.command ?
                context.data.request.command.toLowerCase() : '';
            return patterns.reduce((r, pattern) => Math.max(r, relevanceProvider(pattern, commandLower)), 0);
        };
    }
    static createMatcherFromRegExp(regexp) {
        return (context) => {
            const commandLower = context.data.request.command ?
                context.data.request.command.toLowerCase() : '';
            return regexp.test(commandLower) ? 1 : 0;
        };
    }
    static createMatcherAlways() {
        return () => 1;
    }
    static createMatcherNever() {
        return () => 0;
    }
}
exports.Command = Command;
