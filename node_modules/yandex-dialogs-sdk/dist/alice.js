"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const imagesApi_1 = require("./imagesApi");
const webhookServer_1 = require("./server/webhookServer");
const constants_1 = require("./constants");
const inMemorySessionStorage_1 = require("./session/inMemorySessionStorage");
const sessionMiddleware_1 = require("./session/sessionMiddleware");
const debug_1 = __importDefault(require("./debug"));
const mainScene_1 = require("./stage/mainScene");
class Alice {
    constructor(config = {}) {
        this._eventEmitter = new events_1.EventEmitter();
        this._config = config;
        this.handleRequest = this.handleRequest.bind(this);
        this._middlewares = [];
        this._imagesApi = new imagesApi_1.ImagesApi(this._config);
        this._mainStage = new mainScene_1.MainStage();
        this._sessionStorage =
            config.sessionStorage || new inMemorySessionStorage_1.InMemorySessionStorage();
        this.use(sessionMiddleware_1.sessionMiddleware(this._sessionStorage));
    }
    _buildContext(request) {
        return {
            data: request,
            message: request.request.command,
            originalUtterance: request.request.original_utterance,
            sessionId: request.session.session_id,
            messageId: request.session.message_id,
            userId: request.session.user_id,
            payload: request.request.payload,
            nlu: request.request.nlu,
        };
    }
    async _runMiddlewares(context) {
        const middlewares = Array.from(this._middlewares);
        // mainStage middleware should always be the latest one
        middlewares.push(this._mainStage.middleware);
        if (middlewares.length === 0) {
            return context;
        }
        let index = 0;
        const next = async (middlewareContext) => {
            const middleware = middlewares[index];
            index++;
            return middleware(middlewareContext, index >= middlewares.length ? null : next);
        };
        return next(context);
    }
    get imagesApi() {
        return this._imagesApi;
    }
    async handleRequest(data) {
        if (data.version !== constants_1.ALICE_PROTOCOL_VERSION) {
            throw new Error('Unknown protocol version');
        }
        debug_1.default(`incoming request: ${data.request.command}`);
        const context = this._buildContext(data);
        // trigger request event
        this._eventEmitter.emit('request', context);
        const newContext = await this._runMiddlewares(context);
        if (!newContext.response) {
            throw new Error('No response for request ' +
                `"${context.data.request.command}"` +
                '. Try add command for it or add default command.' +
                '${context.response} not found. Check out your middlewares');
        }
        // trigger response event
        this._eventEmitter.emit('response', newContext);
        debug_1.default(`outcoming result: ${newContext.response.text}`);
        return {
            response: newContext.response,
            session: {
                message_id: data.session.message_id,
                session_id: data.session.session_id,
                user_id: data.session.user_id,
            },
            version: constants_1.ALICE_PROTOCOL_VERSION,
        };
    }
    listen(port = 80, webhookUrl = '/', options = {}) {
        const server = new webhookServer_1.WebhookServer({
            port: port,
            webhookUrl: webhookUrl,
            options: options,
            handleRequest: this.handleRequest,
        });
        server.start();
        return server;
    }
    use(middleware) {
        this._middlewares.push(middleware);
    }
    command(declaration, callback) {
        this._mainStage.scene.command(declaration, callback);
    }
    any(callback) {
        this._mainStage.scene.any(callback);
    }
    registerScene(scene) {
        this._mainStage.stage.addScene(scene);
    }
    on(type, callback) {
        this._eventEmitter.addListener(type, callback);
    }
}
exports.Alice = Alice;
