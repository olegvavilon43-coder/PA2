"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const scene_1 = require("./scene");
const compere_1 = require("./compere");
const constants_1 = require("./constants");
const debug_1 = __importDefault(require("../debug"));
class Stage {
    constructor() {
        this._scenes = new Map();
    }
    addScene(scene) {
        if (!(scene instanceof scene_1.Scene)) {
            throw new Error('Incorrect argument scene. Please provide Scene instance');
        }
        if (this._scenes.has(scene.name)) {
            throw new Error(`Duplicate scene name "${scene.name}"`);
        }
        this._scenes.set(scene.name, scene);
        debug_1.default(`scene added "${scene.name}"`);
    }
    removeScene(name) {
        if (!this._scenes.has(name)) {
            throw new Error(`No scene with name "${name}"`);
        }
        this._scenes.delete(name);
        debug_1.default(`scene removed "${name}"`);
    }
    getMiddleware() {
        return async (context, next) => {
            if (!context.session) {
                throw new Error('You have to add some session middelware to use scenes');
            }
            const sceneName = (await context.session.get(constants_1.CURRENT_SCENE_SESSION_KEY)) ||
                constants_1.DEFAULT_SCENE_NAME;
            const scene = this._scenes.has(sceneName)
                ? this._scenes.get(sceneName)
                : this._scenes.has(constants_1.DEFAULT_SCENE_NAME)
                    ? this._scenes.get(constants_1.DEFAULT_SCENE_NAME)
                    : null;
            if (!scene) {
                return next ? next(context) : context;
            }
            const compere = new compere_1.StageCompere(context);
            const stageContext = Object.assign(Object.assign({}, context), { enter: (name) => compere.enter(name), leave: () => compere.leave() });
            const result = await scene.run(stageContext);
            if (!result) {
                return next ? next(stageContext) : stageContext;
            }
            stageContext.response = result;
            return stageContext;
        };
    }
}
exports.Stage = Stage;
